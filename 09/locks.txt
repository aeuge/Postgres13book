
sudo -u postgres psql

SELECT * FROM pg_locks \gx
SELECT pg_backend_pid();
SELECT pg_blocking_pids(pid);
SHOW log_lock_waits;


CREATE DATABASE locks;
\c locks
-- увидим, что pid изменился
SELECT pg_backend_pid();
CREATE TABLE accounts(id integer, amount numeric);
INSERT INTO accounts VALUES (1,2000.00), (2,2000.00), (3,2000.00);

-- во втором окне
gcloud compute ssh postgres
sudo -u postgres psql
\c locks
begin;
SELECT pg_backend_pid();
SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted FROM pg_locks WHERE pid = 33394;
UPDATE accounts SET amount = amount + 1 WHERE id = 1;
-- смотрим опять блокировки - что изменилось и почему?

-- зайдем в первом терминале
CREATE INDEX ON accounts(id);
-- Что произойдет?
-- проверим во втором терминале
SELECT pg_backend_pid();
SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted FROM pg_locks WHERE pid = 33394;
SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted FROM pg_locks;
-- узнаем, кто нас блокирует
-- таймаут лока
-- https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-LOCK-TIMEOUT
SELECT pg_blocking_pids(33066); 

-- и что вообще происходит PG_STAT_ACTIVITY
SELECT * FROM pg_stat_activity WHERE pid = ANY(pg_blocking_pids(14352)) \gx
commit;

-- рекомендательные блокировки advisory_lock
-- https://postgrespro.ru/docs/postgrespro/12/functions-admin#FUNCTIONS-ADVISORY-LOCKS
-- во втором терминале
begin; 
SELECT hashtext('заблокируй меня полностью');
SELECT pg_advisory_lock(hashtext('заблокируй меня полностью'));
SELECT pg_backend_pid();
SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted FROM pg_locks WHERE pid = 33260;

--попробуем в первом терминале
SELECT pg_advisory_lock(hashtext('заблокируй меня полностью'));

-- во втором терминале
-- что произойдет? почему, как думаете?
commit; 










-- commit не освобождает блокировку
SELECT pg_advisory_unlock(hashtext('заблокируй меня полностью'));
-- только под своим PID


--блокировка строк
-- объяснения про побитовую маску
-- https://habr.com/ru/company/postgrespro/blog/445820/
CREATE EXTENSION pageinspect;
CREATE VIEW accounts_v AS
SELECT '(0,'||lp||')' AS ctid,
       t_xmax as xmax,
       CASE WHEN (t_infomask & 1024) > 0  THEN 't' END AS commited,
       CASE WHEN (t_infomask & 2048) > 0  THEN 't' END AS aborted,
       CASE WHEN (t_infomask & 128) > 0   THEN 't' END AS lock_only,
       CASE WHEN (t_infomask & 4096) > 0  THEN 't' END AS is_multi,
       CASE WHEN (t_infomask2 & 8192) > 0 THEN 't' END AS keys_upd
FROM heap_page_items(get_raw_page('accounts',0))
WHERE lp <= 10
ORDER BY lp;


SELECT * FROM accounts_v ;
truncate accounts;
INSERT INTO accounts VALUES (1,2000.00), (2,2000.00), (3,2000.00);
SELECT * FROM accounts_v ;

begin;
UPDATE accounts set id = 4 WHERE id = 1;
UPDATE accounts set amount = 4000 WHERE id = 3;
SELECT * FROM accounts_v ;
-- что изменилось?

-- во втором терминале
begin;
SELECT * FROM accounts WHERE id = 2 FOR KEY SHARE;
SELECT * FROM accounts WHERE id = 3 FOR KEY SHARE;
SELECT * FROM accounts_v;
CREATE EXTENSION pgrowlocks;
SELECT * FROM pgrowlocks('accounts') \gx

-- Очередь ожидания
CREATE VIEW locks_v AS
SELECT pid,
       locktype,
       CASE locktype
         WHEN 'relation' THEN relation::REGCLASS::text
         WHEN 'virtualxid' THEN virtualxid::text
         WHEN 'transactionid' THEN transactionid::text
         WHEN 'tuple' THEN relation::REGCLASS::text||':'||tuple::text
       END AS lockid,
       mode,
       granted
FROM pg_locks;


SELECT * FROM locks_v;

-- заблокируем строку в разделяемом режиме
begin;
SELECT txid_current(), pg_backend_pid();
SELECT * FROM accounts WHERE id = 3 FOR SHARE;
-- второй терминал
begin;
UPDATE accounts set amount = 4000 WHERE id = 3;
SELECT * FROM locks_v WHERE pid = 5371;//в первом терминале
SELECT pg_blocking_pids(5636);
-- третий терминал
gcloud compute ssh postgres
sudo -u postgres psql
\c locks

SELECT * FROM accounts WHERE id = 3 FOR SHARE;
SELECT * FROM pgrowlocks('accounts') \gx

-- обычно получаем блокировку, а в этом режиме получим ошибку
SELECT * FROM accounts FOR UPDATE NOWAIT; 
-- третий терминал
rollback;
begin;
-- для многопоточной обработки данных
DECLARE c CURSOR FOR SELECT * FROM accounts ORDER BY id FOR UPDATE SKIP LOCKED;
FETCH C; 

-- попытка посмотреть блокировки
SELECT pid, backend_type, wait_event_type, wait_event FROM pg_stat_activity;
pgbench -i locks
pgbench -T 30 locks

